---
title: "Day 07: Automating Security Operations (The 429 Analyzer)"
date: "2026-01-28"
tags: ["Automation", "Python", "ChatOps", "Cloud Armor", "GCP"]
difficulty: "Advanced"
status: "completed"
excerpt: "I got tired of manual forensics on Rate Limit alerts. So I wrote a Python engine to automate the investigation and deliver the verdict to Google Chat."
---

## üìâ The Pain Point: "Alert Fatigue"
In Cloud Security, "Visibility" is often a double-edged sword.
We have Cloud Armor policies set up to block high-volume attacks (Rate Limiting). When these rules trigger (sending a `429 Too Many Requests` to the attacker), GCP sends an email alert.

The problem? **The email is generic.**
It tells you *that* a spike happened, but not *who* caused it. To understand if it's a real DDoS or just a misconfigured client, I usually have to:
1. Open Cloud Logging.
2. Write a complex query.
3. Export 10,000 logs to CSV.
4. Pivot the data to find the Top IPs.
5. Run WHOIS lookups manually.

This takes 15-20 minutes per alert. Today, I decided to automate it down to **0 seconds**.

---

## ü§ñ The Solution: ChatOps Automation
I wrote a custom Python engine that acts as a **Digital Forensics Analyst**.
Instead of me reacting to an email, the script runs automatically.

**The Logic Flow:**
1. **Ingest:** It takes the timestamp and Load Balancer ID from the incident context.
2. **Query:** It hits the Google Cloud Logging API to fetch the raw `429` error logs.
3. **Analyze:** It parses thousands of entries to identify the **Top 3 Offending IPs**.
4. **Enrich:** It performs a realtime **WHOIS/RDAP lookup** to attribute the IP to an ISP (e.g., "DigitalOcean") and a Country (e.g., "Russia").
5. **Report:** It constructs a rich UI Card and pushes it directly to our internal **Google Chat** room via Webhook.

---

## üíª The Engine
Below is the core logic of the analyzer. I've sanitized the sensitive webhooks and IDs, but the forensic logic is fully intact.

```python
#!/usr/bin/env python3
"""
Cloud Armor Incident Auto-Investigator
Author: Pratik Shetti
Logic: Logs API -> Aggregation -> WHOIS Enrichment -> Chat Webhook
"""

import sys
import csv
import requests
import urllib.parse
import re
import uuid
import time
import random
from datetime import datetime, timedelta, timezone
from collections import Counter

# ... [Imports and Dependency Checks Omitted for Brevity] ...

# CONFIGURATION
# (Sanitized for Public Display)
WEBHOOK_URL = "https://chat.googleapis.com/v1/spaces/YOUR_SPACE/messages?key=YOUR_KEY"

class IncidentAnalyzer:
    def __init__(self):
        # Initialize GCP Logging Client
        self.client = self.init_gcp_client()

    def run_analysis(self):
        # 1. Define the Time Window (-30m to +15m of alert)
        start_window = self.inputs['start_time'] - timedelta(minutes=30)
        end_window = self.inputs['start_time'] + timedelta(minutes=15)
        
        # 2. Fetch Logs via API
        logs = self.fetch_logs_with_retry(start_window, end_window, phase="Phase 1")
        
        # 3. Identify Top Offenders
        top_ips, _ = self.extract_top_offenders(logs)

        # 4. Deep Dive & Enrichment
        ip_analysis = self.analyze_specific_ips(top_ips, start_window, end_window)
        enriched_data = self.enrich_with_whois(ip_analysis)
        
        # 5. Push to Chat
        self.send_webhook_report(enriched_data, len(logs))

    def enrich_with_whois(self, data):
        """Attributes IPs to physical locations and ISPs"""
        for ip in data:
            try:
                obj = IPWhois(ip)
                res = obj.lookup_rdap(depth=1)
                data[ip]['country'] = res.get('asn_country_code', 'Unknown')
                data[ip]['isp'] = res.get('network', {}).get('name', 'Unknown')
            except:
                data[ip]['country'] = "Unknown"
        return data

    def send_webhook_report(self, data, total_hits):
        """Constructs the Google Chat JSON Card"""
        # ... [Card Construction Logic] ...
        # Sends POST request to Google Chat API
```

*(Note: The full source code handles API retries, pagination for 20k+ logs, and formatting.)*

---

## üì® The Result
Instead of a vague email, my team now sees this **Card** in our operations channel immediately after an attack starts.

```
üö® Cloud Armor Incident Analysis
Load Balancer: frontend-prod-lb
Total 429s Blocked: 4,203

#1 IP: 203.0.113.5 (CN - Chinanet Backbone)
üìä Traffic Distribution:
  ‚Ä¢ Total Requests: 3,500
  ‚Ä¢ Accepted (2xx): 0
  ‚Ä¢ Blocked (4xx/5xx): 3,500

üö´ Top Blocking Rules:
  Rule 1000 (Rate Limit), Rule 9000 (SQLi)

üåê Top Targeted URLs:
  /api/v1/login (3,500 hits)

[ üîé OPEN LOGS IN GCP ]
```

---

## üß† Why This Matters
This script transforms **Raw Data** into **Actionable Intelligence**.

**Before:** "We are seeing errors." ‚Üí Spend 15 mins digging.

**After:** "Chinanet is credential stuffing the login endpoint." ‚Üí Immediate decision (Block subnet or ignore).

This is the difference between "Managing Cloud" and "Engineering Cloud."
